## HELPER

"""to display abbreviated versions of integers"""
abbreviated(n) = "..."*string(n)[end-2:end]


## EXPOSED SHOW METHODS

# short version of showing a `BaseType` object:
function Base.show(stream::IO, object::BaseType)
    str = string(typeof(object).name.name,
                        "@", abbreviated(objectid(object)))
    if !isempty(fieldnames(typeof(object)))
        printstyled(IOContext(stream, :color=> true), str,
                    color=:blue)
    else
        print(stream, str)
    end
end

# longer version of showing a `BaseType` object (used at REPL):
function Base.show(stream::IO, ::MIME"text/plain", object::BaseType)
    _recursive_show(stream, object, 1, DEFAULT_SHOW_DEPTH)
end

# version showing a `BaseType` object to arbitrary depth:
function Base.show(stream::IO, object::BaseType, depth::Int)
    _recursive_show(stream, object, 1, depth)
end

# for convenience:
Base.show(object::BaseType, depth::Int) = show(stdout, object, depth)
macro more()
    esc(quote
        show(Main.ans, 100)
    end)
end    


## METHODS TO SUPRESS THE DISPLAY OF LARGE NON-BASETYPE OBJECTS

istoobig(::Any) = true
istoobig(::Number) = false
istoobig(x::AbstractArray) = maximum(size(x)) > 5 
istoobig(d::Dict{T,Any}) where T <: Union{Number,Symbol} = length(keys(d)) > 5


## THE `_show` METHOD

# Note: The `_show` method controls how field values are displayed in
# the table generated by `_recursive_show`. See top of file.

# _show fallback:
function _show(stream::IO, object)
    if !istoobig(object)
        show(stream, MIME("text/plain"), object)
        println(stream)
    else
        println(stream, "omitted ", typeof(object))
    end
end

# _show for BaseType:
_show(stream::IO, object::BaseType) = println(stream, object)

# _show for other types:
function _show(stream::IO, df::AbstractDataFrame)
    println(stream, "omitted $(typeof(df)) of size $(size(df))")
end

function _show(stream::IO, A::Array{T}) where T
    if !istoobig(A)
        show(stream, MIME("text/plain"), A)
        println(stream)
    else
        println(stream, "omitted Array{$T} of size $(size(A))")
    end
end

function _show(stream::IO, d::Dict{T, Any}) where T <: Union{Number,Symbol}
    if isempty(d)
        println(stream, "empty $(typeof(d))")
    elseif !istoobig(d)
        println(stream, "omitted $(typeof(d)) with keys: ")
        show(stream, MIME("text/plain"), collect(keys(d)))
        println(stream)
    else
        println(stream, "omitted $(typeof(d))")
    end
end

function _show(stream::IO, v::Array{T, 1}) where T
    if !istoobig(v)
        show(stream, MIME("text/plain"), v)
        println(stream)
    else
        println(stream, "omitted Vector{$T} of length $(length(v))")
    end
end

_show(stream::IO, ::Nothing) = println(stream, "nothing")

"""
    _recursive_show(stream, object, current_depth, depth)

Generate a table of the field values of the `BaseType` object,
dislaying each value by calling the method `_show` on it. The
behaviour of `_show(stream, f)` is as follows:

1. If `f` is itself a `BaseType` object, then its short form is shown
and `_recursive_show` generates as separate table for each of its
field values (and so on, up to a depth of argument `depth`).

2. Otherwise `f` is displayed as "omitted T" where `T = typeof(f)`,
unless `istoobig(f)` is false (the `istoobig` fall-back for arbitrary
types being `true`). In the latter case, the long (ie,
MIME"plain/text") form of `f` is shown. To override this behaviour,
overload the `_show` method for the type in question. 

"""
function _recursive_show(stream::IO, object::BaseType, current_depth, depth)
    if depth == 0 || isempty(fieldnames(typeof(object)))
        println(stream, object)
    elseif current_depth <= depth 
        names = fieldnames(typeof(object))
        print(stream, "#"^current_depth, " ")
        show(stream, object)
        println(stream, ": ")
        if isempty(names)
            println(stream)
            return
        end
        for fld in names
            fld_string = string(fld)*" "^(max(0,COLUMN_WIDTH - length(string(fld))))*"=>   "
            print(stream, fld_string)
            if isdefined(object, fld)
                _show(stream, getfield(object, fld))
                #           println(stream)
            else
                println(stream, "(undefined)")
                #           println(stream)
            end
        end
        println(stream)
        for fld in names
            if isdefined(object, fld)
                subobject = getfield(object, fld)
                if isa(subobject, BaseType) && !isempty(fieldnames(typeof(subobject)))
                    _recursive_show(stream, getfield(object, fld),
                                    current_depth + 1, depth)
                end
            end
        end
    end
end



